#!/bin/bash

EXE_NAME="nay"

NAME="Not Another Yogurt"

VERSION="0.1.0"

HELP_MSG="$NAME $VERSION

Usage: $EXE_NAME [<flags>] <command>

Flags:
  -v, --version  output version information and exit
  -h, --help     display this help and exit

Commands:
   init              Create an empty setup
   add               Add a directory/file to the setup setup
   sync              Syncs the config files
   pull_force        Pull the config from remote and REPLACES the local one
   pkg               Intalls all the packages that can be installed with yay
   nonpkg            Intalls all the packages that can not be instaled with yay
   bootstrap         Sets up the configs files and software
   ssh               Sets all the git origins to use ssh
   full_sync         Executes pkg, nonpkg and sync
"
#########
# MISC  #
#########

## trap ctrl-c and call ctrl_c()
trap ctrl_c INT
function ctrl_c() {
        printf "\n\nAborted, exiting...\n"
        exit 127
}

#########
# Paths #
#########

# config 
global_config_dir="$HOME/.config/$EXE_NAME"

repos_file="$global_config_dir/repos"

# Local
local_dir="$HOME/.local/share/$EXE_NAME"

repos_dir="$local_dir/repos"

#######
# Aux #
#######
function set_repo_dir(){
  if [ -z $1 ] ; then 
    echo "No repo provided use one of the following or init a new one."
    ls "$repos_dir"
    exit 1
  fi
  repo_dir="$repos_dir/$1"
  repo_file_dir="$repo_dir/files"
  repo_dirs="$repo_dir/dirs"
  repo_mnt="$repo_dir/mnt"
  repo_sync_hook="$repo_dir/sync_hook"
  repo_config="$repo_dir/config"
  if [ ! -d "$repo_dir" ] ; then
    printf "Not initialized, please initialize it with '$EXE_NAME init' first\n"
    exit 1
  fi
}

############
# Commands #
############

## ADD
function add(){
  set_repo_dir $1
  shift

  mnt_point=$(bash -c "echo `cat $repo_mnt`" | sed 's#/$##g')

  if [ -z $1 ] ; then
    echo "Nothing specified, nothing added."
    exit 1
  fi

  while [ $# -gt 0 ]; do
    rp="`realpath $1`" 
    rel_rp="`realpath $1 --relative-to="$mnt_point"`" 


    if [ ! -e "$rp" ] ; then
      echo "WARNING: No file on `realpath $rp`" 
      shift
      continue
    elif [ "`echo $rel_rp | cut -d'/' -f1`" = ".." ] ; then
      echo "WARNING: $rp outside $mnt_point"
      shift
      continue
    fi

    mkdir -p "$repo_file_dir/${rel_rp%/*}" 
    [ -e "$repo_file_dir$rp" ] || cp -ur --preserve=timestamps --no-preserve=mode,ownership "$rp" "$repo_file_dir/${rel_rp%/*}"

    # TODO do not add subdirs of already included dirs
    if [ -d "$rp" ] ; then
      grep "$rel_rp" $repo_dirs &> /dev/null || echo "$rel_rp" >> $repo_dirs
    fi

    shift
  done
}

## PULL 
function pull_force() {
  set_repo_dir $1

  git -C "$local_dir" fetch -q || exit $?

  git -C "$local_dir" reset --hard &>/dev/null || exit $?

  printf "\nlocal    cache <- remote\n"
  if [ -z "`git -C "$local_dir" rev-list HEAD..origin/master`" ] ; then
    printf "No changes\n"
  else
    git -C "$local_dir" diff --name-status HEAD origin/master
    git -C "$local_dir" pull origin master &>/dev/null || exit $?

    for FILE in $(git -C "$local_dir" ls-files) ; do
      TIME=$(git -C "$local_dir" log --pretty=format:%cd -n 1 --date=iso -- "$local_dir/$FILE")
      TIME=`echo $TIME | sed 's/-//g;s/ //;s/://;s/:/\./;s/ .*//'`
      touch -m -t "$TIME" "$local_dir/$FILE"
    done
  fi

  printf "\nlocal <- cache    remote\n"
  find "$repo_file_dir" | while IFS= read -r backup; do
    real="/`realpath --relative-to="$repo_file_dir" "$backup"`"

    [ -d $backup ] && continue 

    if [ -f $real ] ; then
      if ! cmp $real $backup &> /dev/null ; then
        printf "M %s\n" "$real"
        cp --preserve=timestamps --no-preserve=mode,ownership "$backup" "$real" &> /dev/null ||\
          (sudo cp --preserve=timestamps --no-preserve=mode,ownership "$backup" "$real" || exit $?)
      fi
    elif [ ! -d $real ] ; then
      printf "A %s\n" "$real"
      mkdir -p "${real%/*}"
      cp --preserve=timestamps --no-preserve=mode,ownership "$backup" "$real" ||\
        (sudo cp --preserve=timestamps --no-preserve=mode,ownership "$backup" "$real" || exit $?)
    fi
  done

  sh $repo_sync_hook
}

## SYNC
function sync() {
  set_repo_dir $1

  mnt_point=$(bash -c "echo `cat $repo_mnt`" | sed 's#/$##g')

  if git -C "$repo_dir" rebase --show-current-patch &>/dev/null ; then
    mergeinfo=`git -c core.editor=true -C "$repo_dir" rebase --continue 2>&1`
    if [ $? -ne 0 ] ; then
      echo "$mergeinfo"
      exit $?
    else
      echo "Conflicts resolved, proceeding with the synchronization"
    fi
  fi
  
  git -C "$repo_dir" fetch -q || exit $?

  printf "\nlocal -> cache    remote\n"
  if [ -d $repo_dirs ] ; then
    cat $repo_dirs | while read dir ; do
      add "$mnt_point/$dir/*"
    done
  fi

  for FILE in $(git -C "$repo_file_dir" ls-tree -r --name-only origin/master) ; do
    real=$mnt_point/$FILE
    backup=$repo_file_dir/$FILE

    if [ -f $real ] ; then
      mkdir -p "${backup%/*}"
      cp -u --preserve=timestamps --no-preserve=mode,ownership "$real" "$backup"
    elif [ ! -d $real ] ; then
      rm "$backup" &>/dev/null
    else
      echo "Expected file or nothing on'$real' but found a directory \nPlease rename the directory and run '$EXE_NAME sync' again\n"
      exit 1
    fi
  done

  git -C "$repo_dir" add . &>/dev/null
  git -C "$repo_dir" commit -m "`hostname`" &>/dev/null

  if [ -z "`git -C "$repo_dir" rev-list origin/master..HEAD`" ] ; then
    printf "No changes\n"
  else
    git -C "$repo_dir" diff --name-status  HEAD~1 HEAD
  fi

  printf "\nlocal    cache <- remote\n"
  if [ -z "`git -C "$repo_dir" rev-list HEAD..origin/master`" ] ; then
    printf "No changes\n"
  else
    git -C "$repo_dir" diff --name-status HEAD origin/master
    git -C "$repo_dir" rebase origin/master &>/dev/null
    if git -C "$repo_dir" rebase --show-current-patch &>/dev/null ; then
      echo
      git -C "$repo_dir" rebase --continue
      exit $?
    fi

    for FILE in $(git -C "$repo_dir" ls-files) ; do
      TIME=$(git -C "$repo_dir" log --pretty=format:%cd -n 1 --date=iso -- "$repo_dir/$FILE")
      TIME=`echo $TIME | sed 's/-//g;s/ //;s/://;s/:/\./;s/ .*//'`
      touch -m -t "$TIME" "$repo_dir/$FILE"
    done
  fi

  printf "\nlocal    cache -> remote\n"
  if [ -z "`git -C "$repo_dir" rev-list origin/master..HEAD`" ] ; then
    printf "No changes\n"
  else
    git -C "$repo_dir" diff --name-status origin/master HEAD
    git -C "$repo_dir" push origin master -q || exit $?
  fi

  printf "\nlocal <- cache    remote\n"
  export change=0

  while IFS= read -r backup; do
    [ -d $backup ] && continue 

    real="$mnt_point/`realpath --relative-to="$repo_file_dir" "$backup"`"

    if [ -f $real ] ; then
        if [ $backup -nt $real ] ;then
          if ! cmp -s $backup $real ; then
            export change=1 
            printf "M %s\n" "$real"
            cp -u --preserve=timestamps --no-preserve=mode,ownership "$backup" "$real" &> /dev/null ||\
              (sudo cp -u --preserve=timestamps --no-preserve=mode,ownership "$backup" "$real" || exit $?)
          else
            export change=1
            printf "T %s\n" "$real"
            touch -r "$backup" "$real" || (sudo touch -r "$backup" "$real" || exit $?)
          fi
        # elif [ $backup -ot $real ] ; then
        #   printf "T %s\n" "$real"
        #   if cmp -s $backup $real ; then 
        #     touch -r "$backup" "$real" || (sudo touch -r "$backup" "$real" || exit $?)
        #   fi
        fi
    elif [ ! -d $real ] ; then
      export change=1
      printf "A %s\n" "$real"
      mkdir -p "${real%/*}"
      cp --preserve=timestamps --no-preserve=mode,ownership "$backup" "$real" ||\
        (sudo cp --preserve=timestamps --no-preserve=mode,ownership "$backup" "$real" || exit $?)
    fi
  done << EOF
`find "$repo_file_dir"`
EOF

  if [ $change -eq 0 ] ; then
    printf "No changes\n"
  fi

  sh $repo_sync_hook
}

## INIT 
function init() {
  repo_url=$1
  if [ -z $repo_url ] ; then
    printf "Enter a valid (e.g. empty) git repository to keep your setup (ssh and private recomended):\n"
    read repo_url
  fi
  repo_name="`echo ${repo_url##*/} | cut -d'.' -f1`"
  repo_dir="$repos_dir/$repo_name"

  if [ -d "$repo_dir/.git" ] ; then
    printf "Already initialized\nTry '$EXE_NAME --help' for more information.\n"
    return 1
  fi

  if [ -d "$repo_dir" ] ; then
    printf "Dirty directory remove?[Y/n]:"
    read awns
    [ ! -z $awns ] && [ $awns != "y" ] && exit 0
    rm -rf "$repo_dir"
    printf "\n"
  fi

  # set up 
  mkdir -p $repo_dir  
  set_repo_dir ${repo_name}

  (git -C "$repo_dir" init -b master &>/dev/null &&\
    git -C "$repo_dir" remote add origin $repo_url &>/dev/null) || exit $?

  git  -C "$repo_dir" pull origin master &>/dev/null

  mkdir -p $repo_file_dir  
  touch $repo_sync_hook

  if [ -z "$(ls -A $repo_dir | grep -v ".git" )" ] ; then
    printf "Enter a mount point for the files [\$HOME]:"
    read mnt
    [ -z $mnt ] && mnt="\$HOME"
    echo "$mnt" > "$repo_dir/mnt"
  fi

  git -C "$repo_dir" add . &>/dev/null
  git -C "$repo_dir" commit -m "`hostname`" &>/dev/null
  git -C "$repo_dir" push -u origin master &>/dev/null

  printf "Initialized!\n"
}

function pkg() {

  yay -v &> /dev/null
  if [ $? -ne 0 ] ; then
    echo ":: yay not installed, installing..."
    sudo pacman -Syu
    sudo pacman -S --noconfirm --needed git base-devel 
    git config --global pull.rebase true
    cd /tmp
    git clone https://aur.archlinux.org/yay.git
    cd yay
    makepkg -si
    echo
    yay -S reflector
  fi

  yay -Syu

  printf "\n-> updating mirror list\n"
  sudo reflector --verbose --latest 10 --sort rate --save /etc/pacman.d/mirrorlist

  echo "-> installing all packages"
  # yay -S --needed --noredownload  --norebuild \
  #        --batchinstall --sudoloop \
  #        `cat "$local_dir/packages" | sed -e '/^[ \t]*#/d' | sed '/^$/d'`
  for pkg in `cat "$local_dir/packages" | sed -e '/^[ \t]*#/d' | sed '/^$/d'` ; do
    if ! yay -Q "$pkg" &> /dev/null ; then
      if ! yay -Qg "$pkg" &> /dev/null ; then
        yay -S --noconfirm --needed --noredownload --answerclean --sudoloop "$pkg"
      fi
    fi
  done
}

function nonpkg() {
  $local_dir/nonpkg
}

function bootstrap() {
  init
  echo
  echo "dotfiles"
  pull_force 
  echo "pkgs"
  pkg
  echo
  echo "non pkgs"
  nonpkg
  $local_dir/bootstrap
}

function ssh(){
  for dir in "$HOME/.build/"* ; do
    cd "$dir"
    git remote set-url origin `git remote get-url origin | sed 's,https://github.com/,git@github.com:,g'`
  done
}

function full_sync() {
  set_repo_dir $1
  echo "------------"
  echo "| Packages |"
  echo "------------"
  pkg
  echo "----------------"
  echo "| Non Packages |"
  echo "----------------"
  nonpkg
  echo "---------"
  echo "| Files |"
  echo "---------"
  sync
}
########
# Main #
########
while [ $# -gt 0 ]; do
  case "$1" in
    -h|--help)
      echo "$HELP_MSG"
      exit 0
      ;;
    -v|--version)
      echo "$VERSION"
      exit 0
      ;;
    init|ssh|add|sync|pkg|nonpkg|script|bootstrap|pull_force|full_sync)
      $@  
      exit $?
      ;;
    -*)
      echo "'$1' is not a $EXE_NAME flag. See '$EXE_NAME --help'."
      exit 2
      ;;
    *)
      echo "'$1' is not a $EXE_NAME command. See '$EXE_NAME --help'."
      exit 2
      ;;
  esac
  shift
done

printf "missing command\nTry '$EXE_NAME --help' for more information.\n"
