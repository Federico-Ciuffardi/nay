#!/bin/bash

source "/usr/lib/naylib"

EXE_NAME="nay"

NAME="Not Another Yogurt"

VERSION="0.1.0"

HELP_MSG="$NAME $VERSION

Usage: $EXE_NAME [<flags>] <command>

Flags:
  -v, --version  output version information and exit
  -h, --help     display this help and exit

Commands:
   init              Create an empty setup
   add               Add a directory/file to the setup setup
   sync              Syncs the config files
   pull_force        Pull the config from remote and REPLACES the local one
   ssh               Sets all the git origins to use ssh
"
#########
# MISC  #
#########

## trap ctrl-c and call ctrl_c()
trap ctrl_c INT
function ctrl_c() {
        printf "\n\nAborted, exiting...\n"
        exit 127
}

#########
# Paths #
#########

# config 
global_config_dir="$HOME/.config/$EXE_NAME"

repos_file="$global_config_dir/repos"

# Local
local_dir="$HOME/.local/share/$EXE_NAME"

repos_dir="$local_dir/repos"

#######
# Aux #
#######
function set_repo(){
  if [ -z $1 ] ; then 
    [ -z $repo_file_dir ] || return 0
    echo "No repo provided use one of the following or init a new one."
    ls "$repos_dir"
    exit 1
  fi

  repo_dir="$repos_dir/$1"

  if [ ! -d "$repo_dir" ] ; then
    printf "Not initialized, please initialize it with '$EXE_NAME init' first\n"
    exit 1
  fi

  repo_file_dir="$repo_dir/files"
  repo_dirs="$repo_dir/dirs"
  repo_sync_hook="$repo_dir/sync_hook"
  repo_sync_hooks="$repo_dir/sync_hooks"
  repo_config="$repo_dir/config"
  repo_mnt="$repo_dir/mnt"

  [ -f $repo_mnt ] && mnt_point=$(bash -c "echo `cat $repo_mnt`" | sed 's#/$##g')
  [ -z $mnt_point ] && mnt_point='/'

}

function sync_hooks(){
  if [ -d $repo_sync_hooks ] && [ ! -z "$(ls -A $repo_sync_hooks)" ]  ; then
    draw_heading "Sync Hooks"
    increase_heading_level
    for f in $repo_sync_hooks/*; do
      draw_heading "${f##*/}"
      increase_heading_level
      source "$f"
      decrease_heading_level
    done
    decrease_heading_level
  fi
}

############
# Commands #
############

# ADD
function add(){
  set_repo $1
  shift

  if [ -z $1 ] ; then
    echo "Nothing specified, nothing added."
    exit 1
  fi

  while [ $# -gt 0 ]; do
    rp="`realpath $1`" 
    rel_rp="`realpath $1 --relative-to="$mnt_point"`" 

    if [ ! -e "$rp" ] ; then
      printf " \u001b[31mx\u001b[0m "
      echo "No file on `realpath $rp`" 
      shift
      continue
    elif [ "`echo $rel_rp | cut -d'/' -f1`" = ".." ] ; then
      printf " \u001b[31mx\u001b[0m "
      echo "$rp outside $mnt_point"
      shift
      continue
    fi

    rel_rp_aux="/$rel_rp"
    mkdir -p "$repo_file_dir${rel_rp_aux%/*}" 
    [ -e "$repo_file_dir$rp" ] || cp -ur --preserve=timestamps --no-preserve=mode,ownership "$rp" "$repo_file_dir${rel_rp_aux%/*}"

    # TODO do not add subdirs of already included dirs
    if [ -d "$rp" ] ; then
      grep "$rel_rp" $repo_dirs &> /dev/null || echo "$rel_rp" >> $repo_dirs
    fi

    shift
  done
}

## PULL 
function pull_force() {
  set_repo $1

  draw_heading "Pull Force"
  increase_heading_level

  git -C "$repo_dir" fetch -q || exit $?

  git -C "$repo_dir" reset --hard &>/dev/null || exit $?

  draw_heading  "local    cache <- remote"
  if [ -z "`git -C "$repo_dir" rev-list HEAD..origin/master`" ] ; then
    printf "No changes\n"
  else
    git -C "$repo_dir" diff --name-status HEAD origin/master
    git -C "$repo_dir" pull origin master &>/dev/null || exit $?

    for FILE in $(git -C "$repo_dir" ls-files) ; do
      TIME=$(git -C "$repo_dir" log --pretty=format:%cd -n 1 --date=iso -- "$repo_dir/$FILE")
      TIME=`echo $TIME | sed 's/-//g;s/ //;s/://;s/:/\./;s/ .*//'`
      touch -m -t "$TIME" "$repo_dir/$FILE"
    done
  fi

  draw_heading "local <- cache    remote"
  find "$repo_file_dir" | while IFS= read -r backup; do
    real="`echo $mnt_point | sed 's#/$##g'`/`realpath --relative-to="$repo_file_dir" "$backup"`"

    [ -d $backup ] && continue 

    if [ -f $real ] ; then
      if ! cmp $real $backup &> /dev/null ; then
        printf "M %s\n" "$real"
        cp --preserve=timestamps --no-preserve=mode,ownership "$backup" "$real" &> /dev/null ||\
          (sudo cp --preserve=timestamps --no-preserve=mode,ownership "$backup" "$real" || exit $?)
      fi
    elif [ ! -d $real ] ; then
      printf "A %s\n" "$real"
      mkdir -p "${real%/*}"
      cp --preserve=timestamps --no-preserve=mode,ownership "$backup" "$real" ||\
        (sudo cp --preserve=timestamps --no-preserve=mode,ownership "$backup" "$real" || exit $?)
    fi
  done

  decrease_heading_level
  sync_hooks
}

## SYNC
function sync() {
  if [ ! -z $1 ] && [ $1 = "--all" ] ; then
    for repo in `ls "$repos_dir"` ; do
      reset_heading_level
      printf "\u001b[32;1m$repo\u001b[0m\n"
      sync $repo
      printf "\n"
    done
    exit 0
  fi

  set_repo $1

  draw_heading "Sync"
  increase_heading_level

  if git -C "$repo_dir" rebase --show-current-patch &>/dev/null ; then
    mergeinfo=`git -c core.editor=true -C "$repo_dir" rebase --continue 2>&1`
    if [ $? -ne 0 ] ; then
      echo "$mergeinfo"
      exit $?
    else
      echo "Conflicts resolved, proceeding with the synchronization"
    fi
  fi
  
  git -C "$repo_dir" fetch -q || exit $?

  draw_heading "local -> cache    remote"
  if [ -d $repo_dirs ] ; then
    cat $repo_dirs | while read dir ; do
      add "$mnt_point/$dir/*"
    done
  fi

  for FILE in $(git -C "$repo_file_dir" ls-tree -r --name-only origin/master) ; do
    real=$mnt_point/$FILE
    backup=$repo_file_dir/$FILE

    if [ -f $real ] ; then
      mkdir -p "${backup%/*}"
      cp -u --preserve=timestamps --no-preserve=mode,ownership "$real" "$backup"
    elif [ ! -d $real ] ; then
      rm "$backup" &>/dev/null
    else
      echo "Expected file or nothing on'$real' but found a directory \nPlease rename the directory and run '$EXE_NAME sync' again\n"
      exit 1
    fi
  done

  git -C "$repo_dir" add . &>/dev/null
  git -C "$repo_dir" commit -m "`hostname`" &>/dev/null

  if [ -z "`git -C "$repo_dir" rev-list origin/master..HEAD`" ] ; then
    printf "No changes\n"
  else
    git -C "$repo_dir" diff --name-status  HEAD~1 HEAD
  fi

  draw_heading "local    cache <- remote"
  if [ -z "`git -C "$repo_dir" rev-list HEAD..origin/master`" ] ; then
    printf "No changes\n"
  else
    git -C "$repo_dir" diff --name-status HEAD origin/master
    git -C "$repo_dir" rebase origin/master &>/dev/null
    if git -C "$repo_dir" rebase --show-current-patch &>/dev/null ; then
      echo
      git -C "$repo_dir" rebase --continue
      exit $?
    fi

    for FILE in $(git -C "$repo_dir" ls-files) ; do
      TIME=$(git -C "$repo_dir" log --pretty=format:%cd -n 1 --date=iso -- "$repo_dir/$FILE")
      TIME=`echo $TIME | sed 's/-//g;s/ //;s/://;s/:/\./;s/ .*//'`
      touch -m -t "$TIME" "$repo_dir/$FILE"
    done
  fi

  draw_heading "local    cache -> remote"
  if [ -z "`git -C "$repo_dir" rev-list origin/master..HEAD`" ] ; then
    printf "No changes\n"
  else
    git -C "$repo_dir" diff --name-status origin/master HEAD
    git -C "$repo_dir" push origin master -q || exit $?
  fi

  draw_heading "local <- cache    remote"
  export change=0

  while IFS= read -r backup; do
    [ -d $backup ] && continue 

    real="`echo $mnt_point | sed 's#/$##g'`/`realpath --relative-to="$repo_file_dir" "$backup"`"

    if [ -f $real ] ; then
        if [ $backup -nt $real ] ;then
          if ! cmp -s $backup $real ; then
            export change=1 
            printf "M %s\n" "$real"
            cp -u --preserve=timestamps --no-preserve=mode,ownership "$backup" "$real" &> /dev/null ||\
              (sudo cp -u --preserve=timestamps --no-preserve=mode,ownership "$backup" "$real" || exit $?)
          else
            export change=1
            printf "T %s\n" "$real"
            touch -r "$backup" "$real" &>/dev/null || (sudo touch -r "$backup" "$real" || exit $?)
          fi
        # elif [ $backup -ot $real ] ; then
        #   printf "T %s\n" "$real"
        #   if cmp -s $backup $real ; then 
        #     touch -r "$backup" "$real" || (sudo touch -r "$backup" "$real" || exit $?)
        #   fi
        fi
    elif [ ! -d $real ] ; then
      export change=1
      printf "A %s\n" "$real"
      mkdir -p "${real%/*}"
      cp --preserve=timestamps --no-preserve=mode,ownership "$backup" "$real" ||\
        (sudo cp --preserve=timestamps --no-preserve=mode,ownership "$backup" "$real" || exit $?)
    fi
  done << EOF
`find "$repo_file_dir"`
EOF

  if [ $change -eq 0 ] ; then
    printf "No changes\n"
  fi

  decrease_heading_level
  sync_hooks
}

## INIT 
function init() {
  repo_url=$1
  if [ -z $repo_url ] ; then
    printf "Enter a valid (e.g. empty) git repository to keep your setup (ssh and private recomended):\n"
    read repo_url
  fi
  repo_name="`echo ${repo_url##*/} | cut -d'.' -f1`"
  repo_dir="$repos_dir/$repo_name"

  if [ -d "$repo_dir/.git" ] ; then
    printf "Already initialized\nTry '$EXE_NAME --help' for more information.\n"
    return 1
  fi

  if [ -d "$repo_dir" ] ; then
    printf "Dirty directory remove?[Y/n]:"
    read awns
    [ ! -z $awns ] && [ $awns != "y" ] && exit 0
    rm -rf "$repo_dir"
    printf "\n"
  fi

  # set up 
  mkdir -p $repo_dir  
  set_repo ${repo_name}

  (git -C "$repo_dir" init -b master &>/dev/null &&\
    git -C "$repo_dir" remote add origin $repo_url &>/dev/null) || exit $?

  git  -C "$repo_dir" pull origin master &>/dev/null

  mkdir -p $repo_file_dir  
  mkdir -p $repo_sync_hooks

  if [ ! -f $repo_mnt ] ; then
    printf "Enter a mount point for the files [\$HOME]:"
    read mnt
    [ -z $mnt ] && mnt="\$HOME"
    echo "$mnt" > "$repo_dir/mnt"
  fi

  git -C "$repo_dir" add . &>/dev/null
  git -C "$repo_dir" commit -m "`hostname`" &>/dev/null
  git -C "$repo_dir" push -u origin master &>/dev/null

  printf "Initialized!\n"
}

function ssh(){
  for dir in "$HOME/.build/"* ; do
    cd "$dir"
    git remote set-url origin `git remote get-url origin | sed 's,https://github.com/,git@github.com:,g'`
  done
}

########
# Main #
########
while [ $# -gt 0 ]; do
  case "$1" in
    -h|--help)
      echo "$HELP_MSG"
      exit 0
      ;;
    -v|--version)
      echo "$VERSION"
      exit 0
      ;;
    init|ssh|add|sync|pkg|nonpkg|script|bootstrap|pull_force|full_sync)
      $@  
      exit $?
      ;;
    -*)
      echo "'$1' is not a $EXE_NAME flag. See '$EXE_NAME --help'."
      exit 2
      ;;
    *)
      echo "'$1' is not a $EXE_NAME command. See '$EXE_NAME --help'."
      exit 2
      ;;
  esac
  shift
done

printf "missing command\nTry '$EXE_NAME --help' for more information.\n"
