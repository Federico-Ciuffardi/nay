#!/usr/bin/env bash

source "/usr/lib/naylib"

EXE_NAME="nay"

NAME="Not Another Yogurt"

VERSION="0.1.0"

HELP_MSG="$NAME $VERSION

Usage: $EXE_NAME [<flags>] <command>

Flags:
  -v, --version  output version information and exit
  -h, --help     display this help and exit

Commands:
   init              Create an empty setup
   add               Start tracking a directory/file
   remove            Stop tracking a directory/file 
   sync              Syncs all the tracked files
   pull_force        Pull the config from remote and REPLACES the local one
"
#########
# MISC  #
#########

## trap ctrl-c and call ctrl_c()
trap ctrl_c INT
function ctrl_c() {
        printf "\n\nAborted, exiting...\n"
        exit 127
}

#########
# Paths #
#########

# config 
global_config_dir="$HOME/.config/$EXE_NAME"

repos_file="$global_config_dir/repos"

# Local
local_dir="$HOME/.local/share/$EXE_NAME"

repos_dir="$local_dir/repos"

#######
# Aux #
#######
function set_repo(){
  repo_dir="$repos_dir/$1"

  if [ ! -d "$repo_dir" ] ; then
    printf "Not initialized, please initialize it with '$EXE_NAME init' first\n"
    exit 1
  fi

  repo_name=$1
  repo_file_dir="$repo_dir/files"
  repo_file_metadata="$repo_dir/metadata"
  repo_dirs="$repo_dir/dirs"
  repo_sync_hook="$repo_dir/sync_hook"
  repo_sync_hooks="$repo_dir/sync_hooks"
  repo_config="$repo_dir/config"
  repo_mnt="$repo_dir/mnt"
  repo_encrypted="$repo_dir/encrypted"

  [ ! -f $repo_mnt ] || mnt_point=$(bash -c "echo `cat $repo_mnt`" | sed 's#/$##g')
  [ ! -z $mnt_point ] || mnt_point='/'

}

function sync_hooks(){
  if [ -d $repo_sync_hooks ] && [ ! -z "$(ls -A $repo_sync_hooks)" ]  ; then
    draw_heading "Sync Hooks"
    increase_heading_level
    for f in $repo_sync_hooks/*; do
      draw_heading "${f##*/}"
      increase_heading_level
      $f
      decrease_heading_level
    done
    decrease_heading_level
  fi
}

function  print_warning(){
  printf " \u001b[33m!\u001b[0m "
  echo "$1"
}
function  print_error(){
  printf " \u001b[31mx\u001b[0m "
  echo "$1"
}

function set_gpg(){
  [ $GPG_SET -eq 1 ] && return
  command -V gpg >/dev/null 2>&1 && GPG="gpg" || GPG="gpg2"
	PASSWORD_STORE_DIR="${PASSWORD_STORE_DIR:-$HOME/.password-store}"
  if [ ! -r "$PASSWORD_STORE_DIR/.gpg-id" ] || ! "$GPG" --list-secret-keys "$(cat "$PASSWORD_STORE_DIR/.gpg-id")" >/dev/null 2>&1 ; then 
    print_error "Encryption needs a password store"
    echo "First run \`pass init <yourgpgemail>\` to set up a password archive."
    echo "(If you don't already have a GPG key pair, first run \`$GPG --full-generate-key\`.)"
    exit 1 
  fi
  if [ ! -f $PASSWORD_STORE_DIR/nay.gpg ] ; then
    print_warning "Set a password for nay. Must match the last used nay password."
    echo "Use the command \`pass insert nay\` to set"
  fi
  GPG_SET=1
}

############
# Commands #
############
# REMOVE
function remove(){
  set_repo $1
  shift

  if [ $# -eq 0 ] ; then
    echo "Nothing specified, nothing removed."
    exit 1
  fi

  while [ $# -gt 0 ]; do
    rp="$(realpath $1)" 
    rel_rp="$(realpath $1 --relative-to="$mnt_point")" 

    rel_rp_aux="/$rel_rp"
    repo_rp="$repo_file_dir$rel_rp_aux"

    if [ ! -e "$rp" ] ; then
      print_error "No file on $rp" 
      shift
      continue
    elif [ "$(echo $rel_rp | cut -d'/' -f1)" = ".." ] ; then
      print_error "$rp outside $mnt_point"
      shift
      continue
    elif [ ! -e "$repo_rp" ] ; then
      print_error "$rp not tracked on $repo_name"
      shift
      continue
    fi

    rm -r $repo_rp
    sed -i "\#^$rel_rp#d" $repo_dirs  
    sed -i "\#^$rel_rp#d" $repo_encrypted  

    while IFS= read -r FILE; do
      sed -i "\#^$FILE #d" $repo_file_metadata 
    done << EOF
$(find "$rel_rp" -type f)
EOF
    shift
  done

}

# ADD
function add(){
  set_repo $1
  shift

  encrypt_flag=0
  files=""
  
  while [ $# -gt 0 ]; do
    case $1 in
      -e|--encrypt)
          set_gpg
          encrypt_flag=1
        ;;
      *)
        files="$files$1"$'\n'
        ;;
    esac
    shift
  done

  if [ -z "$files" ] ; then
    echo "Nothing specified, nothing added."
    exit 1
  fi

  OLDIFS=$IFS
  IFS=$'\n'
  for file in $files ; do
    rp="$(realpath $file)" 
    rel_rp="$(realpath $file --relative-to="$mnt_point")" 

    if [ ! -e "$rp" ] ; then
      print_error "No file on $rp" 
      continue
    elif [ "$(echo $rel_rp | cut -d'/' -f1)" = ".." ] ; then
      print_error "$rp outside $mnt_point"
      continue
    fi

    rel_rp_aux="/$rel_rp"
    mkdir -p "$repo_file_dir${rel_rp_aux%/*}" # remove the last file/dir from the rel_rp_aux path ex /home/fede -> /home
    # [ -e "$repo_file_dir$rel_rp_aux" ] ||
    if [ $encrypt_flag -eq 0 ] ; then
      cp -ur --preserve=timestamps --no-preserve=mode,ownership "$rp" "$repo_file_dir${rel_rp_aux%/*}"
    else
      if [ -d $file ] ; then
        print_error "$rp is directory, encryption can't handle directories yet"
        continue
      fi
      pass show nay | gpg --output "$repo_file_dir${rel_rp_aux}" --no-symkey-cache --pinentry-mode=loopback --batch --yes --passphrase-fd 0 --symmetric "$rp" &>/dev/null
      grep -x "$rel_rp" $repo_encrypted &>/dev/null || echo "$rel_rp" >> $repo_encrypted
    fi

    if [ -d "$rp" ] ; then
      grep -x "$rel_rp" $repo_dirs &>/dev/null || echo "$rel_rp" >> $repo_dirs
    fi
  done
  IFS=$OLDIFS

}

function remote2cache() {
  if [ -z "`git -C "$repo_dir" rev-list HEAD..origin/master`" ] ; then
    printf "No changes\n"
  else
    git -C "$repo_dir" --no-pager diff --name-status HEAD origin/master
    case $1 in
      pull_force)
        git -C "$repo_dir" pull origin master &>/dev/null
        ;;
      sync)
        git -C "$repo_dir" rebase origin/master &>/dev/null || true
        if git -C "$repo_dir" rebase --show-current-patch &>/dev/null ; then
         echo
         git -C "$repo_dir" rebase --continue
         exit $?
        fi
        ;;
    esac

    for FILE in $(git -C "$repo_dir" ls-files) ; do
      TIME=$(git -C "$repo_dir" log --pretty=format:%cd -n 1 --date=iso -- "$repo_dir/$FILE")
      TIME=`echo $TIME | sed 's/-//g;s/ //;s/://;s/:/\./;s/ .*//'`
      touch -m -t "$TIME" "$repo_dir/$FILE"
    done
  fi
}

function cache2local() {
  export change=0

  while IFS= read -r backup; do
    [ ! -d $backup ] || continue 
    relative="`realpath --relative-to="$repo_file_dir" "$backup"`"
    real="`echo $mnt_point | sed 's#/$##g'`/$relative"

    if grep -x "$relative" $repo_encrypted &>/dev/null ; then
      set_gpg
      decripted=$(mktemp)
      pass show nay | gpg --output "$decripted" --no-symkey-cache --pinentry-mode=loopback --batch --yes --passphrase-fd 0 "$backup" &>/dev/null
      touch -r "$backup" "$decripted" &>/dev/null
      backup="$decripted"
    fi

    if [ -f $real ] ; then
        if [ $1 = "pull_force" ] || [ $backup -nt $real ] ;then
          if ! cmp -s $backup $real ; then
            export change=1 
            printf "M %s\n" "$real"
            cp --preserve=timestamps --no-preserve=mode,ownership "$backup" "$real" &> /dev/null ||\
              (sudo cp --preserve=timestamps --no-preserve=mode,ownership "$backup" "$real")
          else
            # export change=1 (tecnically a change but not necesary to let the user know as no datais modified)
            # printf "T %s\n" "$real"
            touch -r "$backup" "$real" &>/dev/null || (sudo touch -r "$backup" "$real")
          fi
        fi
    elif [ ! -d $real ] ; then
      export change=1
      printf "A %s\n" "$real"
      mkdir -p "${real%/*}" &> /dev/null || sudo mkdir -p "${real%/*}"
      cp --preserve=timestamps --no-preserve=mode,ownership "$backup" "$real" &> /dev/null ||\
        (sudo cp --preserve=timestamps --no-preserve=mode,ownership "$backup" "$real")
    fi
  done << EOF
`find "$repo_file_dir"`
EOF

  if [ $change -eq 0 ] ; then
    printf "No changes\n"
  fi

  if [ -f $repo_file_metadata ] ; then
    cat $repo_file_metadata | while read line ; do
      file=$mnt_point/$(echo "$line" | cut -d' ' -f1)
      permissions=$(echo "$line" | cut -d' ' -f2)
      owner=$(echo "$line" | cut -d' ' -f3)
      group=$(echo "$line" | cut -d' ' -f4)
      [ $(stat --format="%a" $file) = $permissions ] || \
        chmod $permissions $file &> /dev/null || sudo chmod $permissions $file
      [ $(stat --format="%U" $file) = $owner ] || \
        chown $owner $file &> /dev/null|| sudo chown $owner $file
      [ $(stat --format="%G" $file) = $group ] || \
        chgrp $group $file &> /dev/null|| sudo chgrp $group $file
    done
  fi

}

## PULL FORCE
function pull_force() {
  if [ ! -z $1 ] && [ $1 = "--all" ] ; then
    for repo in `ls "$repos_dir"` ; do
      reset_heading_level
      printf "\u001b[32;1m$repo\u001b[0m\n"
      pull_force $repo
      printf "\n"
    done
    exit 0
  fi

  set_repo $1

  draw_heading "Pull Force"
  increase_heading_level

  git -C "$repo_dir" fetch -q

  git -C "$repo_dir" rebase --abort &>/dev/null || true 
  git -C "$repo_dir" reset --hard origin/master &>/dev/null

  draw_heading  "local    cache <- remote"
  remote2cache "pull_force"

  draw_heading "local <- cache    remote"
  cache2local "pull_force"

  # Hooks
  decrease_heading_level
  sync_hooks
}

## SYNC
function sync() {
  if [ ! -z $1 ] && [ $1 = "--all" ] ; then
    for repo in `ls "$repos_dir"` ; do
      reset_heading_level
      printf "\u001b[32;1m$repo\u001b[0m\n"
      sync $repo
      printf "\n"
    done
    exit 0
  fi

  set_repo $1

  draw_heading "Sync"
  increase_heading_level

  MERGED=0
  if git -C "$repo_dir" rebase --show-current-patch &>/dev/null ; then
    if mergeinfo=`git -c core.editor=true -C "$repo_dir" rebase --continue 2>&1` ; then
      MERGED=1
      echo "Conflicts resolved, proceeding with the synchronization"
    else
      echo "$mergeinfo"
      exit 1
    fi
  fi
  
  git -C "$repo_dir" fetch -q

  draw_heading "local -> cache    remote"
  if [ -f $repo_dirs ] ; then
    cat $repo_dirs | while read dir ; do
      add "`echo $1 | sed 's#/$##g'`" $mnt_point/$dir
    done
  fi

  touch $repo_file_metadata
  changes=$(mktemp)

  for FILE in $(git -C "$repo_file_dir" ls-tree -r --name-only origin/master && git -C "$repo_file_dir" ls-files --others --exclude-standard) ; do
    real="`echo $mnt_point | sed 's#/$##g'`/$FILE"
    backup=$repo_file_dir/$FILE

    if [ -f $backup ] || [ -z "$(git -C "$repo_file_dir" ls-tree HEAD $FILE 2>/dev/null)" ] ; then
      if [ -f $real ] && [ $real -nt $backup ] ; then
        mkdir -p "${backup%/*}"
        if ! grep -x "$FILE" $repo_encrypted &>/dev/null ; then
          cp -u --preserve=timestamps --no-preserve=mode,ownership "$real" "$backup"
        else
          set_gpg
          decripted=$(mktemp)
          pass show nay | gpg --output "$decripted" --no-symkey-cache --pinentry-mode=loopback --batch --yes --passphrase-fd 0 "$backup" &>/dev/null

          if ! cmp $real $decripted &>/dev/null ; then
            pass show nay | gpg --output "$backup" --no-symkey-cache --pinentry-mode=loopback --batch --yes --passphrase-fd 0 --symmetric "$real" &>/dev/null
          fi
        fi
        if [ $MERGED -eq 0 ] ; then
          sed -i "s#^$FILE .*\$#$FILE $(stat --format="%a %U %G" $real)#gw$changes" $repo_file_metadata
          if [ ! -s $changes ] ; then 
            echo "$FILE $(stat --format="%a %U %G" $real)" >> $repo_file_metadata
          fi
        fi
      fi
    fi
  done

  if [ ! -z "$(git -C "$repo_file_dir" status --porcelain)" ]; then
    git -C "$repo_dir" add . &>/dev/null
    output_file=$(mktemp)
    git -C "$repo_dir" commit -m "`hostname`" &>"${output_file}" || (cat "${output_file}" && exit 1)
    git -C "$repo_dir" --no-pager diff --name-status  HEAD~1 HEAD
  else
    printf "No changes\n"
  fi

  draw_heading "local    cache <- remote"
  remote2cache "sync"

  draw_heading "local    cache -> remote"
  if [ -z "`git -C "$repo_dir" rev-list origin/master..HEAD`" ] ; then
    printf "No changes\n"
  else
    git -C "$repo_dir" --no-pager diff --name-status origin/master HEAD
    git -C "$repo_dir" push origin master -q
  fi

  draw_heading "local <- cache    remote"
  cache2local "sync"

  # Hooks
  decrease_heading_level
  sync_hooks
}

## INIT 
function init() {
  repo_url=$1
  if [ -z $repo_url ] ; then
    printf "Enter a valid (e.g. empty) git repository to keep your setup (ssh and private recomended):\n"
    read repo_url
  fi
  repo_name="`echo ${repo_url##*/} | cut -d'.' -f1`"
  repo_dir="$repos_dir/$repo_name"

  if [ -d "$repo_dir/.git" ] ; then
    printf "Already initialized\nTry '$EXE_NAME --help' for more information.\n"
    return 1
  fi

  if [ -d "$repo_dir" ] ; then
    printf "Dirty directory remove?[Y/n]:"
    read awns
    [ -z $awns ] || [ $awns = "y" ] || exit 0
    rm -rf "$repo_dir"
    printf "\n"
  fi

  # set up 
  mkdir -p $repo_dir  
  set_repo ${repo_name}

  git -C "$repo_dir" init -b master &>/dev/null
  git -C "$repo_dir" remote add origin $repo_url &>/dev/null

  git  -C "$repo_dir" pull origin master &>/dev/null

  mkdir -p $repo_file_dir  
  mkdir -p $repo_sync_hooks

  if [ ! -f $repo_mnt ] ; then
    printf "Enter a mount point for the files [\$HOME]:"
    read mnt
    [ ! -z $mnt ] || mnt="\$HOME"
    echo "$mnt" > "$repo_dir/mnt"
  fi

  git -C "$repo_dir" add . &>/dev/null
  git -C "$repo_dir" commit -m "`hostname`" &>/dev/null
  git -C "$repo_dir" push -u origin master &>/dev/null

  printf "Initialized!\n"
}

function ssh(){
  for dir in "$HOME/.build/"* ; do
    cd "$dir"
    git remote set-url origin `git remote get-url origin | sed 's,https://github.com/,git@github.com:,g'`
  done
}

########
# Main #
########
if [[ ${DEBUG-} =~ ^1|yes|true$ ]]; then
    set -o xtrace       # Trace the execution of the script (debug)
fi

set -o errexit      # Exit on most errors (see the manual)
set -o nounset      # Disallow expansion of unset variables
set -o pipefail     # Use last non-zero exit code in a pipeline
set -o errtrace     # Ensure the error trap handler is inherited

GPG_SET=0

while [ $# -gt 0 ]; do
  case "$1" in
    -h|--help)
      echo "$HELP_MSG"
      exit 0
      ;;
    -v|--version)
      echo "$NAME $VERSION"
      exit 0
      ;;
    init|ssh|add|remove|sync|pull_force)
      reset_heading_level
      if [ $# -lt 2 ] ; then 
        echo "No repo provided."
        echo "Use one of the following or init a new one."
        ls "$repos_dir"
        exit 1
      fi
      $@  
      exit $?
      ;;
    -*)
      echo "'$1' is not a $EXE_NAME flag. See '$EXE_NAME --help'."
      exit 2
      ;;
    *)
      echo "'$1' is not a $EXE_NAME command. See '$EXE_NAME --help'."
      exit 2
      ;;
  esac
  shift
done

printf "missing command\nTry '$EXE_NAME --help' for more information.\n"
