#!/usr/bin/env bash

source "/usr/lib/naylib"

EXE_NAME="nay"

NAME="Not Another Yogurt"

VERSION="0.1.0"

HELP_MSG="$NAME $VERSION

Usage: $EXE_NAME [<flags>] <command>

Flags:
  -v, --version  output version information and exit
  -h, --help     display this help and exit

Commands:
   init              Create an empty setup
   add               Add a directory/file to the setup setup
   sync              Syncs the config files
   pull_force        Pull the config from remote and REPLACES the local one
   ssh               Sets all the git origins to use ssh
"
#########
# MISC  #
#########

## trap ctrl-c and call ctrl_c()
trap ctrl_c INT
function ctrl_c() {
        printf "\n\nAborted, exiting...\n"
        exit 127
}

#########
# Paths #
#########

# config 
global_config_dir="$HOME/.config/$EXE_NAME"

repos_file="$global_config_dir/repos"

# Local
local_dir="$HOME/.local/share/$EXE_NAME"

repos_dir="$local_dir/repos"

#######
# Aux #
#######
function set_repo(){
  if [ -z $1 ] ; then 
    [ -z $repo_file_dir ] || return 0
    echo "No repo provided use one of the following or init a new one."
    ls "$repos_dir"
    exit 1
  fi

  repo_dir="$repos_dir/$1"

  if [ ! -d "$repo_dir" ] ; then
    printf "Not initialized, please initialize it with '$EXE_NAME init' first\n"
    exit 1
  fi

  repo_file_dir="$repo_dir/files"
  repo_file_metadata="$repo_dir/metadata"
  repo_dirs="$repo_dir/dirs"
  repo_sync_hook="$repo_dir/sync_hook"
  repo_sync_hooks="$repo_dir/sync_hooks"
  repo_config="$repo_dir/config"
  repo_mnt="$repo_dir/mnt"

  [ ! -f $repo_mnt ] || mnt_point=$(bash -c "echo `cat $repo_mnt`" | sed 's#/$##g')
  [ ! -z $mnt_point ] || mnt_point='/'

}

function sync_hooks(){
  if [ -d $repo_sync_hooks ] && [ ! -z "$(ls -A $repo_sync_hooks)" ]  ; then
    draw_heading "Sync Hooks"
    increase_heading_level
    for f in $repo_sync_hooks/*; do
      draw_heading "${f##*/}"
      increase_heading_level
      $f
      decrease_heading_level
    done
    decrease_heading_level
  fi
}

############
# Commands #
############

# ADD
function add(){
  set_repo $1
  shift
  
  if [ $# -eq 0 ] ; then
    echo "Nothing specified, nothing added."
    exit 1
  fi

  while [ $# -gt 0 ]; do
    rp="$(realpath $1)" 
    rel_rp="$(realpath $1 --relative-to="$mnt_point")" 

    if [ ! -e "$rp" ] ; then
      printf " \u001b[31mx\u001b[0m "
      echo "No file on $rp" 
      shift
      continue
    elif [ "$(echo $rel_rp | cut -d'/' -f1)" = ".." ] ; then
      printf " \u001b[31mx\u001b[0m "
      echo "$rp outside $mnt_point"
      shift
      continue
    fi

    rel_rp_aux="/$rel_rp"
    mkdir -p "$repo_file_dir${rel_rp_aux%/*}" # remove the last file/dir from the rel_rp_aux path ex /home/fede -> /home
    # [ -e "$repo_file_dir$rel_rp_aux" ] ||
    cp -ur --preserve=timestamps --no-preserve=mode,ownership "$rp" "$repo_file_dir${rel_rp_aux%/*}"

    if [ -d "$rp" ] ; then
      grep "$rel_rp" $repo_dirs &>/dev/null || echo "$rel_rp" >> $repo_dirs
    fi

    shift
  done
}

function remote2cache() {
  if [ -z "`git -C "$repo_dir" rev-list HEAD..origin/master`" ] ; then
    printf "No changes\n"
  else
    git -C "$repo_dir" --no-pager diff --name-status HEAD origin/master
    case $1 in
      pull_force)
        git -C "$repo_dir" pull origin master &>/dev/null
        ;;
      sync)
        git -C "$repo_dir" rebase origin/master &>/dev/null || true
        if git -C "$repo_dir" rebase --show-current-patch &>/dev/null ; then
         echo
         git -C "$repo_dir" rebase --continue
         exit $?
        fi
        ;;
    esac

    for FILE in $(git -C "$repo_dir" ls-files) ; do
      TIME=$(git -C "$repo_dir" log --pretty=format:%cd -n 1 --date=iso -- "$repo_dir/$FILE")
      TIME=`echo $TIME | sed 's/-//g;s/ //;s/://;s/:/\./;s/ .*//'`
      touch -m -t "$TIME" "$repo_dir/$FILE"
    done
  fi
}

function cache2local() {
  export change=0

  while IFS= read -r backup; do
    [ ! -d $backup ] || continue 

    real="`echo $mnt_point | sed 's#/$##g'`/`realpath --relative-to="$repo_file_dir" "$backup"`"

    if [ -f $real ] ; then
        if [ $1 = "pull_force" ] || [ $backup -nt $real ] ;then
          if ! cmp -s $backup $real ; then
            export change=1 
            printf "M %s\n" "$real"
            cp --preserve=timestamps --no-preserve=mode,ownership "$backup" "$real" &> /dev/null ||\
              (sudo cp --preserve=timestamps --no-preserve=mode,ownership "$backup" "$real" || exit $?)
          else
            # export change=1 (tecnically a change but not necesary to let the user know as no datais modified)
            # printf "T %s\n" "$real"
            touch -r "$backup" "$real" &>/dev/null || (sudo touch -r "$backup" "$real" || exit $?)
          fi
        fi
    elif [ ! -d $real ] ; then
      export change=1
      printf "A %s\n" "$real"
      mkdir -p "${real%/*}" &> /dev/null || sudo mkdir -p "${real%/*}"
      cp --preserve=timestamps --no-preserve=mode,ownership "$backup" "$real" ||\
        (sudo cp --preserve=timestamps --no-preserve=mode,ownership "$backup" "$real" || exit $?)
    fi
  done << EOF
`find "$repo_file_dir"`
EOF

  if [ $change -eq 0 ] ; then
    printf "No changes\n"
  fi

  if [ -f $repo_file_metadata ] ; then
    cat $repo_file_metadata | while read line ; do
      file=$(echo "$line" | cut -d' ' -f1)
      permissions=$(echo "$line" | cut -d' ' -f2)
      owner=$(echo "$line" | cut -d' ' -f3)
      group=$(echo "$line" | cut -d' ' -f4)
      [ $(stat --format="%a" $file) = $permissions ] || \
        chmod $permissions $file &> /dev/null || sudo chmod $permissions $file
      [ $(stat --format="%U" $file) = $owner ] || \
        chown $owner $file &> /dev/null|| sudo chown $owner $file
      [ $(stat --format="%G" $file) = $group ] || \
        chgrp $group $file &> /dev/null|| sudo chgrp $group $file
    done
  fi

}

## PULL FORCE
function pull_force() {
  if [ ! -z $1 ] && [ $1 = "--all" ] ; then
    for repo in `ls "$repos_dir"` ; do
      reset_heading_level
      printf "\u001b[32;1m$repo\u001b[0m\n"
      pull_force $repo
      printf "\n"
    done
    exit 0
  fi

  set_repo $1

  draw_heading "Pull Force"
  increase_heading_level

  git -C "$repo_dir" fetch -q || exit $?

  git -C "$repo_dir" reset --hard &>/dev/null || exit $?

  draw_heading  "local    cache <- remote"
  remote2cache "pull_force"

  draw_heading "local <- cache    remote"
  cache2local "pull_force"

  # Hooks
  decrease_heading_level
  sync_hooks
}

## SYNC
function sync() {
  if [ ! -z $1 ] && [ $1 = "--all" ] ; then
    for repo in `ls "$repos_dir"` ; do
      reset_heading_level
      printf "\u001b[32;1m$repo\u001b[0m\n"
      sync $repo
      printf "\n"
    done
    exit 0
  fi

  set_repo $1

  draw_heading "Sync"
  increase_heading_level

  MERGED=0
  if git -C "$repo_dir" rebase --show-current-patch &>/dev/null ; then
    if mergeinfo=`git -c core.editor=true -C "$repo_dir" rebase --continue 2>&1` ; then
      MERGED=1
      echo "Conflicts resolved, proceeding with the synchronization"
    else
      echo "$mergeinfo"
      exit $?
    fi
  fi
  
  git -C "$repo_dir" fetch -q || exit $?

  draw_heading "local -> cache    remote"
  if [ -f $repo_dirs ] ; then
    cat $repo_dirs | while read dir ; do
      add "`echo $1 | sed 's#/$##g'`" $mnt_point/$dir
    done
  fi

  touch $repo_file_metadata
  changes=$(mktemp)
  buff=$(mktemp)

  for FILE in $(git -C "$repo_file_dir" ls-tree -r --name-only origin/master && git -C "$repo_file_dir" ls-files --others --exclude-standard) ; do
    real="`echo $mnt_point | sed 's#/$##g'`/$FILE"
    backup=$repo_file_dir/$FILE

    if [ -f $real ] ; then
      mkdir -p "${backup%/*}"
      cp -u --preserve=timestamps --no-preserve=mode,ownership "$real" "$backup"
      if [ $MERGED -eq 0 ] ; then
        sed "s#^$real .*\$#$real $(stat --format="%a %U %G" $real)#gw$changes" $repo_file_metadata > $buff
        if [ -s $changes ] ; then 
          cp $buff $repo_file_metadata
        else
          echo "$real $(stat --format="%a %U %G" $real)" >> $repo_file_metadata
        fi
      fi
    fi
  done

  if [ ! -z "$(git -C "$repo_file_dir" status --porcelain)" ]; then
    git -C "$repo_dir" add . &>/dev/null
    output_file=$(mktemp)
    git -C "$repo_dir" commit -m "`hostname`" &>"${output_file}" || (cat "${output_file}" && exit 1)
    git -C "$repo_dir" --no-pager diff --name-status  HEAD~1 HEAD
  else
    printf "No changes\n"
  fi

  draw_heading "local    cache <- remote"
  remote2cache "sync"

  draw_heading "local    cache -> remote"
  if [ -z "`git -C "$repo_dir" rev-list origin/master..HEAD`" ] ; then
    printf "No changes\n"
  else
    git -C "$repo_dir" --no-pager diff --name-status origin/master HEAD
    git -C "$repo_dir" push origin master -q || exit $?
  fi

  draw_heading "local <- cache    remote"
  cache2local "sync"

  # Hooks
  decrease_heading_level
  sync_hooks
}

## INIT 
function init() {
  repo_url=$1
  if [ -z $repo_url ] ; then
    printf "Enter a valid (e.g. empty) git repository to keep your setup (ssh and private recomended):\n"
    read repo_url
  fi
  repo_name="`echo ${repo_url##*/} | cut -d'.' -f1`"
  repo_dir="$repos_dir/$repo_name"

  if [ -d "$repo_dir/.git" ] ; then
    printf "Already initialized\nTry '$EXE_NAME --help' for more information.\n"
    return 1
  fi

  if [ -d "$repo_dir" ] ; then
    printf "Dirty directory remove?[Y/n]:"
    read awns
    [ -z $awns ] || [ $awns = "y" ] || exit 0
    rm -rf "$repo_dir"
    printf "\n"
  fi

  # set up 
  mkdir -p $repo_dir  
  set_repo ${repo_name}

  git -C "$repo_dir" init -b master &>/dev/null
  git -C "$repo_dir" remote add origin $repo_url &>/dev/null

  git  -C "$repo_dir" pull origin master &>/dev/null

  mkdir -p $repo_file_dir  
  mkdir -p $repo_sync_hooks

  if [ ! -f $repo_mnt ] ; then
    printf "Enter a mount point for the files [\$HOME]:"
    read mnt
    [ ! -z $mnt ] || mnt="\$HOME"
    echo "$mnt" > "$repo_dir/mnt"
  fi

  git -C "$repo_dir" add . &>/dev/null
  git -C "$repo_dir" commit -m "`hostname`" &>/dev/null
  git -C "$repo_dir" push -u origin master &>/dev/null

  printf "Initialized!\n"
}

function ssh(){
  for dir in "$HOME/.build/"* ; do
    cd "$dir"
    git remote set-url origin `git remote get-url origin | sed 's,https://github.com/,git@github.com:,g'`
  done
}

########
# Main #
########
if [[ ${DEBUG-} =~ ^1|yes|true$ ]]; then
    set -o xtrace       # Trace the execution of the script (debug)
fi

set -o errexit      # Exit on most errors (see the manual)
set -o nounset      # Disallow expansion of unset variables
set -o pipefail     # Use last non-zero exit code in a pipeline
set -o errtrace     # Ensure the error trap handler is inherited

while [ $# -gt 0 ]; do
  case "$1" in
    -h|--help)
      echo "$HELP_MSG"
      exit 0
      ;;
    -v|--version)
      echo "$NAME $VERSION"
      exit 0
      ;;
    init|ssh|add|sync|pkg|nonpkg|script|bootstrap|pull_force|full_sync)
      reset_heading_level
      $@  
      exit $?
      ;;
    -*)
      echo "'$1' is not a $EXE_NAME flag. See '$EXE_NAME --help'."
      exit 2
      ;;
    *)
      echo "'$1' is not a $EXE_NAME command. See '$EXE_NAME --help'."
      exit 2
      ;;
  esac
  shift
done

printf "missing command\nTry '$EXE_NAME --help' for more information.\n"
